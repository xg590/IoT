### Using Heltec WiFi LoRa 32 V2 as an example
* List GPIO pin numbers by referring IOT/Board/Espressif/ESP32/WIFI_LoRa_32/WIFI_LoRa_32_V2.1.pdf
```
Pin_MISO = 19
Pin_MOSI = 27
Pin_SCK = 5
Pin_CS = 18
Pin_RST = 14;
Pin_DIO0 = 26
Pin_DIO1 = 35
Pin_DIO2 = 34 
```
* Code
```
import time
import math
from ucollections import namedtuple
from urandom import getrandbits
from machine import SPI
from machine import Pin

### LoRa Mode Register Table (Table 41) 
RegFifo           = 0x00
RegOpMode         = 0x01
RegFrfMsb         = 0x06
RegFrfMid         = 0x07
RegFrfLsb         = 0x08
RegPaConfig       = 0x09
RegFifoAddrPtr    = 0x0d
RegFifoTxBaseAddr = 0x0e
RegFifoRxBaseAddr = 0x0f
FifoRxCurrentAddr = 0x10
RegIrqFlags       = 0x12
RegRxNbBytes      = 0x13 # Number of received bytes
RegPktSnrValue    = 0x19
RegModemConfig1   = 0x1d
RegModemConfig2   = 0x1e
RegModemConfig3   = 0x26 
RegPktRssiValue   = 0x1a
RegPreambleMsb    = 0x20 # Size of preamble
RegPreambleLsb    = 0x21
RegPayloadLength  = 0x22
RegDioMapping1    = 0x40 # Mapping of pins DIO0 to DIO3
RegPaDac          = 0x4d # Higher power settings of the PA (Power Amplifier) DAC (Digital Analog Converter)

### LoRa Mode Register Map
PA_DAC_ENABLE  = 0x07 
PA_DAC_DISABLE = 0x04
PaSelect      = 0b1_000_0000 # Select PA_BOOST pin
MaxPower      = 0b0_111_0000 # 15dBm = 10.8 + 0.6 * 7 
OutputPower   = 0b0_000_1111 # 17    = 17 - ( 15 - 0b0_000_1111) since we choose PA_BOOST pin by setting PaSelect


RxDone         = 0b01000000 
TxDone         = 0b00001000
CadDone        = 0b00000100
CadDetected    = 0b00000001 

LongRangeMode     = 0b01000000 
Mode_SLEEP        = 0b00000000
Mode_STDBY        = 0b00000001
Mode_TX           = 0b00000011
Mode_RXCONTINUOUS = 0b00000101
Mode_CAD          = 0b00000111

#Constants
FLAGS_ACK = 0x80
BROADCAST_ADDRESS = 255

  
class LoRa(object):
    def __init__(self, spi_channel, irq_pin, this_address, cs_pin, rst_pin=None, freq=868.0, tx_power=14,
                 modem_config=ModemConfig.Bw125Cr45Sf128, receive_all=False, acks=False, crypto=None):
        """
        Lora(channel, interrupt, this_address, cs_pin, reset_pin=None, freq=868.0, tx_power=14,
                 modem_config=ModemConfig.Bw125Cr45Sf128, receive_all=False, acks=False, crypto=None)
        channel: SPI channel, check SPIConfig for preconfigured names
        irq_pin: GPIO interrupt pin
        this_address: set address for this device [0-254]
        cs_pin: chip select pin from microcontroller 
        rst_pin: the GPIO used to reset the RFM9x if connected
        freq: frequency in MHz
        tx_power: transmit power in dBm
        modem_config: Check ModemConfig. Default is compatible with the Radiohead library
        receive_all: if True, don't filter packets on address
        acks: if True, request acknowledgments
        crypto: if desired, an instance of ucrypto AES (https://docs.pycom.io/firmwareapi/micropython/ucrypto/) - not tested
        """
        
        self._mode = None
        self._cad = None
        self._freq = freq
        self._tx_power = tx_power
        self._modem_config = modem_config
        self._receive_all = receive_all
        self._acks = acks

        self._this_address = this_address
        self._last_header_id = 0

        self._last_payload = None
        self.crypto = crypto

        self.cad_timeout = 0
        self.send_retries = 2
        self.wait_packet_sent_timeout = 0.2
        self.retry_timeout = 0.2
        
        # Pins
        Pin_MISO = 19
        Pin_MOSI = 27
        Pin_SCK = 5
        Pin_CS = 18
        Pin_RST = 14
        Pin_DIO0 = 26
        Pin_DIO1 = 35
        Pin_DIO2 = 34  

        # Reset the board
        if Pin_RST:
            Pin(Pin_RST, Pin.OUT).value(0);  time.sleep(0.01)
            Pin(Pin_RST, Pin.OUT).value(1);  time.sleep(0.01)

        # Release board from SPI Bus
        Pin(Pin_CS,   Pin.OUT).value(1) # Into high impedance status 
        
        # Setup Interrupt
        Pin(Pin_DIO0, Pin.IN ).irq(trigger=Pin.IRQ_RISING, handler=self._handle_interrupt)

        # baud rate to 5MHz 
        self.spi = SPI(id=0, baudrate=5000000, sck=Pin(Pin_SCK), mosi=Pin(Pin_MOSI), miso=Pin(Pin_MISO))
  
        # set mode
        self._spi_write(RegOpMode, Mode_SLEEP | LongRangeMode) 
        time.sleep(0.1) 
        assert self._spi_read(RegOpMode) == (Mode_SLEEP | LongRangeMode), "LoRa initialization failed"
        
        # Use all FIFO buffer. See Datasheet: Principle of Operation
        self._spi_write(RegFifoTxBaseAddr, 0x00) # bottom of the memory
        self._spi_write(RegFifoRxBaseAddr, 0x00)
        self.set_mode_idle()

        # See 4.4. LoRa Mode Register Map
        self._spi_write(RegModemConfig1, 0b0111_001_0)  # Bw:125kHz, CodingRate:4/5, ImplicitHeaderModeOn: On
        self._spi_write(RegModemConfig2, 0b0111_0_0_00) # SpreadingFactor: 7, TxContinuousMode: Normal, RxPayloadCrcOn: On, SymbTimeout(9:8):0
        self._spi_write(RegModemConfig3, 0x04)
 

        # Preamble length (8)
        self._spi_write(RegPreambleMsb, 0x0) # Preamble can be 64kb long, much longer than payload 
        self._spi_write(RegPreambleLsb, 0x8) # but we just use 8-byte preamble

        # 4.1.4. Frequency Settings
        FXOSC = 32e6 # Freq of XOSC
        FSTEP = FXOSC / 2^19
        Frf = int(915e6 / FSTEP)
        self._spi_write(RegFrfMsb, (Frf >> 16) & 0xff)
        self._spi_write(RegFrfMid, (Frf >>  8) & 0xff)
        self._spi_write(RegFrfLsb,  Frf        & 0xff)
         
        # Set tx power
        if self._tx_power < 5:
            self._tx_power = 5
        if self._tx_power > 23:
            self._tx_power = 23
        '''
        {Band 1: ~915MHz, Band 2: ~433MHz, Band 3: ~150MHz}
        {LF: Bands 2&3, HF: Band 1} 
        RFI: RF Input 
        RFO: RF Output
        Three amplifiers: RFO_LF, RFO_HF, PA_BOOST
        AFC: automatic frequency correction 
        PA: Power Amplifier 
        PA_HP: High Power
        PA_HF and PA_LF are high efficiency amplifiers
        RFOP: RF output power
        PaDac is 0x04 or 0x07 
        RegPaDac = 0x10 << 3 | 0x07 # Enables the +20dBm option on PA_BOOST pin
        ''' 
        if self._tx_power < 20:
            self._spi_write(RegPaDac, PA_DAC_ENABLE)
            self._tx_power -= 3
        else:
            self._spi_write(RegPaDac, PA_DAC_DISABLE)

        self._spi_write(RegPaConfig, PA_SELECT | (self._tx_power - 5))
        
    def on_recv(self, message):
        # This should be overridden by the user
        pass

    def sleep(self):
        if self._mode != MODE_SLEEP:
            self._spi_write(RegOpMode, MODE_SLEEP)
            self._mode = MODE_SLEEP

    def set_mode_tx(self):
        if self._mode != MODE_TX:
            self._spi_write(RegOpMode, MODE_TX)
            self._spi_write(REG_40_DIO_MAPPING1, 0x40)  # Interrupt on TxDone
            self._mode = MODE_TX

    def set_mode_rx(self):
        if self._mode != MODE_RXCONTINUOUS:
            self._spi_write(RegOpMode, MODE_RXCONTINUOUS)
            self._spi_write(REG_40_DIO_MAPPING1, 0x00)  # Interrupt on RxDone
            self._mode = MODE_RXCONTINUOUS
            
    def set_mode_cad(self):
        if self._mode != MODE_CAD:
            self._spi_write(RegOpMode, MODE_CAD)
            self._spi_write(REG_40_DIO_MAPPING1, 0x80)  # Interrupt on CadDone
            self._mode = MODE_CAD

    def _is_channel_active(self):
        self.set_mode_cad()

        while self._mode == MODE_CAD:
            yield

        return self._cad
    
    def wait_cad(self):
        if not self.cad_timeout:
            return True

        start = time.time()
        for status in self._is_channel_active():
            if time.time() - start < self.cad_timeout:
                return False

            if status is None:
                time.sleep(0.1)
                continue
            else:
                return status

    def wait_packet_sent(self):
        # wait for `_handle_interrupt` to switch the mode back
        start = time.time()
        while time.time() - start < self.wait_packet_sent_timeout:
            if self._mode != MODE_TX:
                return True

        return False

    def set_mode_idle(self):
        if self._mode != Mode_STDBY:
            self._spi_write(RegOpMode, Mode_STDBY)
            self._mode = Mode_STDBY

    def send(self, data, header_to, header_id=0, header_flags=0):
        self.wait_packet_sent()
        self.set_mode_idle()
        self.wait_cad()

        header = [header_to, self._this_address, header_id, header_flags]
        if type(data) == int:
            data = [data]
        elif type(data) == bytes:
            data = [p for p in data]
        elif type(data) == str:
            data = [ord(s) for s in data]

        if self.crypto:
            data = [b for b in self._encrypt(bytes(data))]

        payload = header + data
        self._spi_write(REG_0D_FIFO_ADDR_PTR, 0)
        self._spi_write(REG_00_FIFO, payload)
        self._spi_write(REG_22_PAYLOAD_LENGTH, len(payload))

        self.set_mode_tx()
        return True

    def send_to_wait(self, data, header_to, header_flags=0, retries=3):
        self._last_header_id += 1

        for _ in range(retries + 1):
            self.send(data, header_to, header_id=self._last_header_id, header_flags=header_flags)
            self.set_mode_rx()

            if header_to == BROADCAST_ADDRESS:  # Don't wait for acks from a broadcast message
                return True

            start = time.time()
            while time.time() - start < self.retry_timeout + (self.retry_timeout * (getrandbits(16) / (2**16 - 1))):
                if self._last_payload:
                    if self._last_payload.header_to == self._this_address and \
                            self._last_payload.header_flags & FLAGS_ACK and \
                            self._last_payload.header_id == self._last_header_id:

                        # We got an ACK
                        return True
        return False

    def send_ack(self, header_to, header_id):
        self.send(b'!', header_to, header_id, FLAGS_ACK)
        self.wait_packet_sent()

    def _spi_write(self, register, payload):
        if type(payload) == int:
            payload = [payload]
        elif type(payload) == bytes:
            payload = [p for p in payload]
        elif type(payload) == str:
            payload = [ord(s) for s in payload]
        self.cs.value(0)
        self.spi.write(bytearray([register | 0x80] + payload))
        self.cs.value(1)

    def _spi_read(self, register, length=1):
        self.cs.value(0) # Bring the CS pin low to enable communication
        if length == 1:
            data = self.spi.read(length + 1, register)[1]
        else:
            data = self.spi.read(length + 1, register)[1:]
        self.cs.value(1) # release the bus.
        return data 

    def _handle_interrupt(self, channel):
        irq_flags = self._spi_read(REG_12_IRQ_FLAGS)

        if self._mode == MODE_RXCONTINUOUS and (irq_flags & RX_DONE):
            packet_len = self._spi_read(REG_13_RX_NB_BYTES)
            self._spi_write(REG_0D_FIFO_ADDR_PTR, self._spi_read(REG_10_FIFO_RX_CURRENT_ADDR))

            packet = self._spi_read(REG_00_FIFO, packet_len)
            self._spi_write(REG_12_IRQ_FLAGS, 0xff)  # Clear all IRQ flags

            snr = self._spi_read(REG_19_PKT_SNR_VALUE) / 4
            rssi = self._spi_read(REG_1A_PKT_RSSI_VALUE)

            if snr < 0:
                rssi = snr + rssi
            else:
                rssi = rssi * 16 / 15

            if self._freq >= 779:
                rssi = round(rssi - 157, 2)
            else:
                rssi = round(rssi - 164, 2)

            if packet_len >= 4:
                header_to = packet[0]
                header_from = packet[1]
                header_id = packet[2]
                header_flags = packet[3]
                message = bytes(packet[4:]) if packet_len > 4 else b''

                if (self._this_address != header_to) and ((header_to != BROADCAST_ADDRESS) or (self._receive_all is False)):
                    return

                if self.crypto and len(message) % 16 == 0:
                    message = self._decrypt(message)

                if self._acks and header_to == self._this_address and not header_flags & FLAGS_ACK:
                    self.send_ack(header_from, header_id)

                self.set_mode_rx()

                self._last_payload = namedtuple(
                    "Payload",
                    ['message', 'header_to', 'header_from', 'header_id', 'header_flags', 'rssi', 'snr']
                )(message, header_to, header_from, header_id, header_flags, rssi, snr)

                if not header_flags & FLAGS_ACK:
                    self.on_recv(self._last_payload)

        elif self._mode == MODE_TX and (irq_flags & TX_DONE):
            self.set_mode_idle()

        elif self._mode == MODE_CAD and (irq_flags & CAD_DONE):
            self._cad = irq_flags & CAD_DETECTED
            self.set_mode_idle()

        self._spi_write(REG_12_IRQ_FLAGS, 0xff)

    def close(self):
        self.spi.deinit()
```
